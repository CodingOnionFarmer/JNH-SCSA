# 언어 : PyPy3
# 메모리 : 49712KB
# 시간 : 184ms
# 시도횟수 : 2회 (리팩토링)


# 구현, 시뮬레이션

"""
방향, x축과 y축, 인덱스에 유의하고, 각 칸에서 어떤 충전기를 충전할 수 있는지 충전량 내림차순으로 넣어서 처리했다.
조건 분기에 유의한다.
"""

# 0 가만히, 1 상, 2 우, 3 하, 4 좌

# directions = ((0, 0), (0, -1), (1, 0), (0, 1), (-1, 0))

# board_move = [[num] * 5 for num in range(100)]
# for i in range(10):
#     for j in range(10):
#         for d in range(1, 5):
#             di, dj = directions[d]
#             ni, nj = i + di, j + dj
#             if 0 <= ni < 10 and 0 <= nj < 10:
#                 board_move[i * 10 + j][d] = ni * 10 + nj
# board_move = tuple(tuple(line) for line in board_move)
# for i in range(10):
#     print(*board_move[i * 10:i * 10 + 10], sep=',', end=',\n')

board_move = (
    (0, 0, 10, 1, 0), (1, 0, 11, 2, 1), (2, 1, 12, 3, 2), (3, 2, 13, 4, 3), (4, 3, 14, 5, 4), (5, 4, 15, 6, 5),
    (6, 5, 16, 7, 6), (7, 6, 17, 8, 7), (8, 7, 18, 9, 8), (9, 8, 19, 9, 9),
    (10, 10, 20, 11, 0), (11, 10, 21, 12, 1), (12, 11, 22, 13, 2), (13, 12, 23, 14, 3), (14, 13, 24, 15, 4),
    (15, 14, 25, 16, 5), (16, 15, 26, 17, 6), (17, 16, 27, 18, 7), (18, 17, 28, 19, 8), (19, 18, 29, 19, 9),
    (20, 20, 30, 21, 10), (21, 20, 31, 22, 11), (22, 21, 32, 23, 12), (23, 22, 33, 24, 13), (24, 23, 34, 25, 14),
    (25, 24, 35, 26, 15), (26, 25, 36, 27, 16), (27, 26, 37, 28, 17), (28, 27, 38, 29, 18), (29, 28, 39, 29, 19),
    (30, 30, 40, 31, 20), (31, 30, 41, 32, 21), (32, 31, 42, 33, 22), (33, 32, 43, 34, 23), (34, 33, 44, 35, 24),
    (35, 34, 45, 36, 25), (36, 35, 46, 37, 26), (37, 36, 47, 38, 27), (38, 37, 48, 39, 28), (39, 38, 49, 39, 29),
    (40, 40, 50, 41, 30), (41, 40, 51, 42, 31), (42, 41, 52, 43, 32), (43, 42, 53, 44, 33), (44, 43, 54, 45, 34),
    (45, 44, 55, 46, 35), (46, 45, 56, 47, 36), (47, 46, 57, 48, 37), (48, 47, 58, 49, 38), (49, 48, 59, 49, 39),
    (50, 50, 60, 51, 40), (51, 50, 61, 52, 41), (52, 51, 62, 53, 42), (53, 52, 63, 54, 43), (54, 53, 64, 55, 44),
    (55, 54, 65, 56, 45), (56, 55, 66, 57, 46), (57, 56, 67, 58, 47), (58, 57, 68, 59, 48), (59, 58, 69, 59, 49),
    (60, 60, 70, 61, 50), (61, 60, 71, 62, 51), (62, 61, 72, 63, 52), (63, 62, 73, 64, 53), (64, 63, 74, 65, 54),
    (65, 64, 75, 66, 55), (66, 65, 76, 67, 56), (67, 66, 77, 68, 57), (68, 67, 78, 69, 58), (69, 68, 79, 69, 59),
    (70, 70, 80, 71, 60), (71, 70, 81, 72, 61), (72, 71, 82, 73, 62), (73, 72, 83, 74, 63), (74, 73, 84, 75, 64),
    (75, 74, 85, 76, 65), (76, 75, 86, 77, 66), (77, 76, 87, 78, 67), (78, 77, 88, 79, 68), (79, 78, 89, 79, 69),
    (80, 80, 90, 81, 70), (81, 80, 91, 82, 71), (82, 81, 92, 83, 72), (83, 82, 93, 84, 73), (84, 83, 94, 85, 74),
    (85, 84, 95, 86, 75), (86, 85, 96, 87, 76), (87, 86, 97, 88, 77), (88, 87, 98, 89, 78), (89, 88, 99, 89, 79),
    (90, 90, 90, 91, 80), (91, 90, 91, 92, 81), (92, 91, 92, 93, 82), (93, 92, 93, 94, 83), (94, 93, 94, 95, 84),
    (95, 94, 95, 96, 85), (96, 95, 96, 97, 86), (97, 96, 97, 98, 87), (98, 97, 98, 99, 88), (99, 98, 99, 99, 89),
)

# most = [[0]]
# for code in range(1, 1 << 8):
#     digit = 0
#     while not code & 1:
#         code >>= 1
#         digit += 1
#     most.append([digit])
#     code >>= 1
#     digit += 1
#     if code:
#         while not code & 1:
#             code >>= 1
#             digit += 1
#         most[-1].append(digit)
#
# print(tuple(tuple(line) for line in most))

largest_two = (
    (0,), (0,), (1,), (0, 1), (2,), (0, 2), (1, 2), (0, 1), (3,), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2),
    (0, 1), (4,), (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3),
    (0, 2), (1, 2), (0, 1), (5,), (0, 5), (1, 5), (0, 1), (2, 5), (0, 2), (1, 2), (0, 1), (3, 5), (0, 3), (1, 3),
    (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (4, 5), (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4),
    (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (6,), (0, 6), (1, 6), (0, 1), (2, 6), (0, 2), (1, 2),
    (0, 1), (3, 6), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (4, 6), (0, 4), (1, 4), (0, 1), (2, 4),
    (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (5, 6), (0, 5), (1, 5),
    (0, 1), (2, 5), (0, 2), (1, 2), (0, 1), (3, 5), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (4, 5),
    (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2),
    (0, 1), (7,), (0, 7), (1, 7), (0, 1), (2, 7), (0, 2), (1, 2), (0, 1), (3, 7), (0, 3), (1, 3), (0, 1), (2, 3),
    (0, 2), (1, 2), (0, 1), (4, 7), (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3),
    (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (5, 7), (0, 5), (1, 5), (0, 1), (2, 5), (0, 2), (1, 2), (0, 1), (3, 5),
    (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (4, 5), (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2),
    (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (6, 7), (0, 6), (1, 6), (0, 1), (2, 6),
    (0, 2), (1, 2), (0, 1), (3, 6), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (4, 6), (0, 4), (1, 4),
    (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2), (0, 1), (5, 6),
    (0, 5), (1, 5), (0, 1), (2, 5), (0, 2), (1, 2), (0, 1), (3, 5), (0, 3), (1, 3), (0, 1), (2, 3), (0, 2), (1, 2),
    (0, 1), (4, 5), (0, 4), (1, 4), (0, 1), (2, 4), (0, 2), (1, 2), (0, 1), (3, 4), (0, 3), (1, 3), (0, 1), (2, 3),
    (0, 2), (1, 2), (0, 1),
)

T = int(input())
for tc in range(1, T + 1):
    m, a = map(int, input().split())
    # A와 B의 경로
    a_path = list(map(int, input().split())) + [0]
    b_path = list(map(int, input().split())) + [0]

    board = [0] * 100
    chargers = sorted([tuple(map(int, input().split())) for _ in range(a)], key=lambda ch: ch[3], reverse=True)
    charge_amount = []

    for idx, (x, y, c, p) in enumerate(chargers):
        charge_amount.append(p)
        for i in range(max(0, x - 1 - c), min(10, x + c)):
            x_dist = abs(x - 1 - i)
            for j in range(max(0, y - 1 - c + x_dist), min(10, y + c - x_dist)):
                board[i * 10 + j] |= 1 << idx

    a_now = 0
    b_now = 99
    ans = 0

    for i in range(m + 1):
        a_code = board[a_now]
        b_code = board[b_now]

        if a_code:
            if b_code:
                lca = largest_two[a_code][0]
                lcb = largest_two[b_code][0]
                if lca == lcb:
                    for c in largest_two[a_code | b_code]:
                        ans += charge_amount[c]
                else:
                    ans += charge_amount[lca]
                    ans += charge_amount[lcb]
            else:
                ans += charge_amount[largest_two[a_code][0]]
        elif b_code:
            ans += charge_amount[largest_two[b_code][0]]

        a_now = board_move[a_now][a_path[i]]
        b_now = board_move[b_now][b_path[i]]

    print(f'#{tc}', ans)
